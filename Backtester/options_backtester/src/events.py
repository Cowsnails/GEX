"""
Event classes for event-driven backtesting architecture.

Implements proper event sequencing to prevent look-ahead bias:
1. MarketEvent - New market data available
2. SignalEvent - Strategy generates trading signal
3. OrderEvent - Portfolio converts signal to order
4. FillEvent - Execution simulates order fill

This architecture ensures events are processed in chronological order.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
import pandas as pd


class EventType(Enum):
    """Event types for the backtesting system."""
    MARKET = 1
    SIGNAL = 2
    ORDER = 3
    FILL = 4


@dataclass
class MarketEvent:
    """
    Represents new market data becoming available.

    Generated by DataHandler when advancing to next timestamp.
    Triggers strategy to calculate signals.
    """
    type: EventType = EventType.MARKET
    timestamp: Optional[pd.Timestamp] = None
    data: Optional[Dict[str, Any]] = None  # Options chain data at this timestamp

    def __str__(self):
        return f"MarketEvent(timestamp={self.timestamp})"


@dataclass
class SignalEvent:
    """
    Represents a trading signal generated by a strategy.

    Triggers portfolio to convert signal into orders.
    """
    type: EventType = EventType.SIGNAL
    symbol: Optional[str] = None
    signal_type: Optional[str] = None  # 'LONG', 'SHORT', 'EXIT'
    strength: Optional[float] = None  # Signal strength (0.0 to 1.0)
    strikes: Optional[List[float]] = None  # For spreads or multi-leg strategies
    strategy_id: Optional[str] = None  # Strategy that generated signal
    metadata: Optional[Dict[str, Any]] = None  # Additional signal data (IV rank, etc.)

    def __str__(self):
        return f"SignalEvent({self.symbol}, {self.signal_type}, strength={self.strength})"


@dataclass
class OrderEvent:
    """
    Represents an order to be executed.

    Generated by Portfolio based on SignalEvent.
    Triggers ExecutionHandler to simulate fill.
    """
    type: EventType = EventType.ORDER
    symbol: Optional[str] = None
    order_type: Optional[str] = None  # 'MARKET', 'LIMIT'
    quantity: Optional[int] = None
    direction: Optional[str] = None  # 'BUY', 'SELL'
    strikes: Optional[List[float]] = None  # Strike prices
    option_types: Optional[List[str]] = None  # 'C' or 'P' for each leg
    limit_price: Optional[float] = None  # For limit orders
    order_id: Optional[str] = None  # Unique order identifier
    timestamp: Optional[pd.Timestamp] = None  # When order was placed

    def __str__(self):
        return f"OrderEvent({self.symbol}, {self.direction} {self.quantity}, {self.order_type})"


@dataclass
class FillEvent:
    """
    Represents a completed order execution.

    Generated by ExecutionHandler after simulating realistic fill.
    Triggers Portfolio to update positions and cash.
    """
    type: EventType = EventType.FILL
    symbol: Optional[str] = None
    quantity: Optional[int] = None
    direction: Optional[str] = None  # 'BUY', 'SELL'
    fill_price: Optional[float] = None  # Actual fill price
    commission: Optional[float] = None  # Commission cost
    timestamp: Optional[pd.Timestamp] = None  # When fill occurred
    slippage: Optional[float] = None  # Slippage amount
    order_id: Optional[str] = None  # Reference to original order
    strikes: Optional[List[float]] = None  # Strike prices filled
    option_types: Optional[List[str]] = None  # Option types filled
    execution_quality: Optional[str] = None  # 'GOOD', 'FAIR', 'POOR'

    def __str__(self):
        return f"FillEvent({self.symbol}, {self.direction} {self.quantity} @ {self.fill_price})"

    def get_cost(self):
        """
        Calculate total cost of fill including commission.

        Returns:
            Positive for buys (cash outflow)
            Negative for sells (cash inflow)
        """
        # Options are priced per share, multiplied by 100 shares per contract
        price_cost = self.fill_price * self.quantity * 100

        if self.direction == 'BUY':
            return price_cost + self.commission
        else:  # SELL
            return -(price_cost - self.commission)


# Helper functions

def create_market_event(timestamp: pd.Timestamp, data: Dict[str, Any]) -> MarketEvent:
    """Factory function to create MarketEvent."""
    return MarketEvent(
        type=EventType.MARKET,
        timestamp=timestamp,
        data=data
    )


def create_signal_event(
    symbol: str,
    signal_type: str,
    strength: float = 1.0,
    strikes: Optional[List[float]] = None,
    strategy_id: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> SignalEvent:
    """Factory function to create SignalEvent."""
    return SignalEvent(
        type=EventType.SIGNAL,
        symbol=symbol,
        signal_type=signal_type,
        strength=strength,
        strikes=strikes,
        strategy_id=strategy_id,
        metadata=metadata
    )


def create_order_event(
    symbol: str,
    order_type: str,
    quantity: int,
    direction: str,
    strikes: Optional[List[float]] = None,
    option_types: Optional[List[str]] = None,
    limit_price: Optional[float] = None,
    order_id: Optional[str] = None,
    timestamp: Optional[pd.Timestamp] = None
) -> OrderEvent:
    """Factory function to create OrderEvent."""
    return OrderEvent(
        type=EventType.ORDER,
        symbol=symbol,
        order_type=order_type,
        quantity=quantity,
        direction=direction,
        strikes=strikes,
        option_types=option_types,
        limit_price=limit_price,
        order_id=order_id,
        timestamp=timestamp
    )


def create_fill_event(
    symbol: str,
    quantity: int,
    direction: str,
    fill_price: float,
    commission: float,
    timestamp: pd.Timestamp,
    slippage: float = 0.0,
    order_id: Optional[str] = None,
    strikes: Optional[List[float]] = None,
    option_types: Optional[List[str]] = None,
    execution_quality: Optional[str] = None
) -> FillEvent:
    """Factory function to create FillEvent."""
    return FillEvent(
        type=EventType.FILL,
        symbol=symbol,
        quantity=quantity,
        direction=direction,
        fill_price=fill_price,
        commission=commission,
        timestamp=timestamp,
        slippage=slippage,
        order_id=order_id,
        strikes=strikes,
        option_types=option_types,
        execution_quality=execution_quality
    )


if __name__ == "__main__":
    # Example usage
    import pandas as pd

    # Create sample events
    market_event = create_market_event(
        timestamp=pd.Timestamp.now(),
        data={'SPY': {}}
    )
    print(market_event)

    signal_event = create_signal_event(
        symbol='SPY',
        signal_type='SHORT',
        strength=0.8,
        strikes=[450.0],
        strategy_id='premium_selling_v1'
    )
    print(signal_event)

    order_event = create_order_event(
        symbol='SPY',
        order_type='MARKET',
        quantity=1,
        direction='SELL',
        strikes=[450.0],
        option_types=['P']
    )
    print(order_event)

    fill_event = create_fill_event(
        symbol='SPY',
        quantity=1,
        direction='SELL',
        fill_price=2.50,
        commission=0.65,
        timestamp=pd.Timestamp.now(),
        slippage=0.02
    )
    print(fill_event)
    print(f"Fill cost: ${fill_event.get_cost():.2f}")
